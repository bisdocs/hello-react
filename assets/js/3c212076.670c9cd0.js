"use strict";(self.webpackChunklearnreact=self.webpackChunklearnreact||[]).push([[143],{5526:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=r(4848),t=r(8453);const s={sidebar_position:2},o="React Fiber",a={id:"react-deep-dive/fiber",title:"React Fiber",description:"Fiber is react's new reconciliation algorithm introduced in React 16",source:"@site/docs/react-deep-dive/fiber.md",sourceDirName:"react-deep-dive",slug:"/react-deep-dive/fiber",permalink:"/hello-react/react-deep-dive/fiber",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"React - Deep Dive",permalink:"/hello-react/category/react---deep-dive"},next:{title:"The use state hook",permalink:"/hello-react/react-deep-dive/state"}},l={},c=[{value:"Fiber",id:"fiber",level:2},{value:"Virtual DOM &amp; Fiber",id:"virtual-dom--fiber",level:2},{value:"Reference",id:"reference",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"react-fiber",children:"React Fiber"}),"\n",(0,i.jsx)(n.p,{children:"Fiber is react's new reconciliation algorithm introduced in React 16"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It is a complete rewrite of the previous reconciliation mechanism."}),"\n",(0,i.jsxs)(n.li,{children:["There was no name given to the previous reconcilation algorithm but we can call it as ",(0,i.jsx)(n.code,{children:"stack reconcilation"})]}),"\n",(0,i.jsx)(n.li,{children:"Fiber is designed to improve the performance and responsiveness of React applications"}),"\n",(0,i.jsx)(n.li,{children:"This helps especially the large and complex component trees."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Incremental Rendering"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Fiber enables React to break down the rendering work into smaller units, or "fibers"'}),"\n",(0,i.jsx)(n.li,{children:"and prioritize which units to work on first."}),"\n",(0,i.jsx)(n.li,{children:"This allows React to spread out the rendering work over multiple frames"}),"\n",(0,i.jsx)(n.li,{children:"making UI updates more incremental and responsive."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Priority scheduling"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fiber introduces the concept of priority levels for different types of updates."}),"\n",(0,i.jsx)(n.li,{children:"React can pause, abort, or defer work on lower-priority updates in favor of higher-priority ones."}),"\n",(0,i.jsx)(n.li,{children:"This prioritization helps ensure that important updates, such as user interactions or animations, are processed more quickly."}),"\n",(0,i.jsx)(n.li,{children:"Low priority updates are like fetching data from server"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Reconciliation phases"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Fiber breaks the reconciliation process into phases, such as "reconciliation," "commit," and "mutation."'}),"\n",(0,i.jsx)(n.li,{children:"Each phase has its own priorities and responsibilities,"}),"\n",(0,i.jsx)(n.li,{children:"This allows React to efficiently manage updates and avoid blocking the main thread."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Time Slicing"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fiber allows react to interrupt long running tasks"}),"\n",(0,i.jsx)(n.li,{children:"and prioritize prioritize rendering updates based on the available CPU resources."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The sudo code of how conceptually the algorithm works."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Incremental rendering\r\nfunction performUnitOfWork(fiber) {\r\n  // Do work for the current fiber\r\n  // e.g., update props, state, etc.\r\n  // Perform side effects\r\n  // Update Fiber's state to reflect work done\r\n  const nextUnitOfWork = /* find the next fiber to work on */;\r\n  return nextUnitOfWork;\r\n}\r\n\r\nfunction workLoop(deadline) {\r\n  let nextUnitOfWork = /* get the next unit of work */;\r\n  while (nextUnitOfWork && deadline.timeRemaining() > 1) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n  }\r\n  if (nextUnitOfWork) {\r\n    requestIdleCallback(workLoop);\r\n  }\r\n}\r\n\r\n// Priority scheduling\r\nfunction scheduleWork(component, priorityLevel) {\r\n  // Determine the priority of the work based on priorityLevel\r\n  // Add component to the queue with the appropriate priority\r\n  // e.g., using a priority queue or similar data structure\r\n}\r\n\r\n// Reconciliation phases\r\nfunction reconcile(fiber) {\r\n  // Perform the reconciliation phase for the given fiber\r\n  // e.g., determine which parts of the component tree need to be updated\r\n}\r\n\r\nfunction commitWork(fiber) {\r\n  // Perform the commit phase for the given fiber\r\n  // e.g., apply updates to the actual DOM\r\n}\r\n\r\n// Time-slicing\r\nfunction workLoopWithTimeSlicing(deadline) {\r\n  let nextUnitOfWork = /* get the next unit of work */;\r\n  while (nextUnitOfWork && deadline.timeRemaining() > 1) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n    if (deadline.timeRemaining() <= 1) {\r\n      requestIdleCallback(workLoopWithTimeSlicing);\r\n    }\r\n  }\r\n  if (nextUnitOfWork) {\r\n    requestIdleCallback(workLoopWithTimeSlicing);\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"fiber",children:"Fiber"}),"\n",(0,i.jsx)(n.p,{children:"The fiber method works like this"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function FiberNode(tag, pendingProps, key, mode) {\r\n  // Instance\r\n  this.tag = tag;\r\n  this.key = key;\r\n  this.elementType = null;\r\n  this.type = null;\r\n  this.stateNode = null; // Fiber\r\n\r\n  this.return = null;\r\n  this.child = null;\r\n  this.sibling = null;\r\n  this.index = 0;\r\n  this.ref = null;\r\n  this.pendingProps = pendingProps;\r\n  this.memoizedProps = null;\r\n  this.updateQueue = null;\r\n  this.memoizedState = null;\r\n  this.dependencies = null;\r\n  this.mode = mode; // Effects\r\n\r\n  this.flags = NoFlags;\r\n  this.subtreeFlags = NoFlags;\r\n  this.deletions = null;\r\n  this.lanes = NoLanes;\r\n  this.childLanes = NoLanes;\r\n  this.alternate = null;\r\n\r\n  {\r\n    // Note: The following is done to avoid a v8 performance cliff.\r\n    //\r\n    // Initializing the fields below to smis and later updating them with\r\n    // double values will cause Fibers to end up having separate shapes.\r\n    // This behavior/bug has something to do with Object.preventExtension().\r\n    // Fortunately this only impacts DEV builds.\r\n    // Unfortunately it makes React unusably slow for some applications.\r\n    // To work around this, initialize the fields below with doubles.\r\n    //\r\n    // Learn more about this here:\r\n    // https://github.com/facebook/react/issues/14365\r\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\r\n    this.actualDuration = Number.NaN;\r\n    this.actualStartTime = Number.NaN;\r\n    this.selfBaseDuration = Number.NaN;\r\n    this.treeBaseDuration = Number.NaN;\r\n    // It's okay to replace the initial doubles with smis after initialization.\r\n    // This won't trigger the performance cliff mentioned above,\r\n    // and it simplifies other profiler code (including DevTools).\r\n\r\n    this.actualDuration = 0;\r\n    this.actualStartTime = -1;\r\n    this.selfBaseDuration = 0;\r\n    this.treeBaseDuration = 0;\r\n  }\r\n\r\n  {\r\n    // This isn't directly used but is handy for debugging internals:\r\n    this._debugSource = null;\r\n    this._debugOwner = null;\r\n    this._debugNeedsRemount = false;\r\n    this._debugHookTypes = null;\r\n\r\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\r\n      Object.preventExtensions(this);\r\n    }\r\n  }\r\n} // This is a constructor function, rather than a POJO constructor, still\r\n// please ensure we do the following:\r\n// 1) Nobody should add any instance methods on this. Instance methods can be\r\n//    more difficult to predict when they get optimized and they are almost\r\n//    never inlined properly in static compilers.\r\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\r\n//    always know when it is a fiber.\r\n// 3) We might want to experiment with using numeric keys since they are easier\r\n//    to optimize in a non-JIT environment.\r\n// 4) We can easily go from a constructor to a createFiber object literal if that\r\n//    is faster.\r\n// 5) It should be easy to port this to a C struct and keep a C implementation\r\n//    compatible.\r\n\r\nvar createFiber = function (tag, pendingProps, key, mode) {\r\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\r\n  return new FiberNode(tag, pendingProps, key, mode);\r\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"virtual-dom--fiber",children:"Virtual DOM & Fiber"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Virtual DOM"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Handles the representation of the UI in memory."}),"\n",(0,i.jsx)(n.li,{children:"Represents the entire UI structure as a tree of lightweight JavaScript objects."}),"\n",(0,i.jsx)(n.li,{children:"Allows React to efficiently compare the current UI state with the new state to identify changes."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Fiber"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Handles the reconciliation and rendering process."}),"\n",(0,i.jsx)(n.li,{children:'Breaks down the rendering work into smaller units called "fibers."'}),"\n",(0,i.jsx)(n.li,{children:"Prioritizes and schedules the rendering work based on its priority levels."}),"\n",(0,i.jsx)(n.li,{children:"Manages the sequence of updates and commits them to the actual DOM."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How they work together"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When changes occur in a React component (e.g., state or props update)"}),"\n",(0,i.jsx)(n.li,{children:"React creates a new Virtual DOM representation of the updated UI."}),"\n",(0,i.jsx)(n.li,{children:"React then compares this new Virtual DOM with the previous one to identify the differences (reconciliation)."}),"\n",(0,i.jsx)(n.li,{children:"Fiber takes over to process these differences incrementally, prioritizing and scheduling the rendering work."}),"\n",(0,i.jsx)(n.li,{children:"Fiber reconciles the changes by updating the Virtual DOM and determining the minimal set of changes needed to update the actual DOM."}),"\n",(0,i.jsx)(n.li,{children:"Finally, Fiber commits these changes to the actual DOM, resulting in the updated UI being rendered to the user."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.youtube.com/watch?v=ZCuYPiUIONs",children:"Fiber React Conf"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.scaler.com/topics/react/react-fiber/",children:"Scaler React Fiber"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/acdlite/react-fiber-architecture",children:"acdlite react-fiber-architecture"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var i=r(6540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);