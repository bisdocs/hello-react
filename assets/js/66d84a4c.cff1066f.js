"use strict";(self.webpackChunklearnreact=self.webpackChunklearnreact||[]).push([[793],{3680:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>a});var t=r(4848),s=r(8453);const i={sidebar_position:5},l="Use Ref Hook",c={id:"react-hooks/use-ref",title:"Use Ref Hook",description:"When we need component to remember some information but don't want to trigger re-render we can use ref",source:"@site/docs/react-hooks/use-ref.md",sourceDirName:"react-hooks",slug:"/react-hooks/use-ref",permalink:"/hello-react/react-hooks/use-ref",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Use Effect Hook",permalink:"/hello-react/react-hooks/use-effect"},next:{title:"React - Deep Dive",permalink:"/hello-react/category/react---deep-dive"}},o={},a=[{value:"Differences between refs and state",id:"differences-between-refs-and-state",level:2},{value:"When to use refs",id:"when-to-use-refs",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Refs and the DOM",id:"refs-and-the-dom",level:2},{value:"Focus on element using ref",id:"focus-on-element-using-ref",level:3},{value:"Forward Ref",id:"forward-ref",level:3},{value:"When React attaches the refs",id:"when-react-attaches-the-refs",level:3},{value:"Best practices for DOM manipulation with refs",id:"best-practices-for-dom-manipulation-with-refs",level:3},{value:"More Info",id:"more-info",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"use-ref-hook",children:"Use Ref Hook"}),"\n",(0,t.jsxs)(n.p,{children:["When we need component to ",(0,t.jsx)(n.code,{children:"remember"})," some information but don't want to trigger re-render we can use ",(0,t.jsx)(n.code,{children:"ref"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"useRef is used to persist values across renders without causing re-renders."}),"\n",(0,t.jsx)(n.li,{children:"Commonly used to reference and interact with DOM elements directly."}),"\n",(0,t.jsxs)(n.li,{children:["Returns a mutable ref object with a ",(0,t.jsx)(n.code,{children:".current"})," property that holds the value."]}),"\n",(0,t.jsxs)(n.li,{children:["We can set an initial value with ",(0,t.jsx)(n.code,{children:"useRef(initialValue)"}),", and .current starts with that value."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { useRef } from 'react';\r\n\r\nexport default function Counter() {\r\n  let ref = useRef(0);\r\n\r\n  function handleClick() {\r\n    ref.current = ref.current + 1;\r\n    alert('You clicked ' + ref.current + ' times!');\r\n  }\r\n\r\n  return (\r\n    <button onClick={handleClick}>\r\n      Click me!\r\n    </button>\r\n  );\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We can point ref to anything like String, Number, Object, function etc"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"let ref = useRef(0);\r\nfunction handleClick() {\r\n  ref.current = ref.current + 1;\r\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We can build a stop watch using this"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:" const intervalRef = useRef(null);\r\n\r\n function handleStart() {\r\n    setStartTime(Date.now());\r\n    setNow(Date.now());\r\n    clearInterval(intervalRef.current);\r\n\r\n    intervalRef.current = setInterval(() => {\r\n      setNow(Date.now());\r\n    }, 10);\r\n  }\r\n\r\n function handleStop() {\r\n    clearInterval(intervalRef.current);\r\n  } \n"})}),"\n",(0,t.jsx)(n.h2,{id:"differences-between-refs-and-state",children:"Differences between refs and state"}),"\n",(0,t.jsx)(n.p,{children:"There are difference between refs and state"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["useRef(initialValue) returns ",(0,t.jsx)(n.code,{children:"{current: initialValue}"}),"\r\nbut useState(initialValue) returns ",(0,t.jsx)(n.code,{children:"[value, setValue]"})]}),"\n",(0,t.jsx)(n.li,{children:"useRef doesn't trigger re-render when changes but useState triggers re-render"}),"\n",(0,t.jsx)(n.li,{children:"In useRef we can modify the value directly (mutable)"}),"\n",(0,t.jsx)(n.li,{children:"States are immutable, we must use the state setting function to change."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"//It will not re-render the component, so updated value will not display\r\n//If we add a alert / console log under handle click we can see the value change\r\nlet countRef = useRef(0);\r\n\r\n  function handleClick() {\r\n    countRef.current = countRef.current + 1;\r\n  }\r\n\r\n  return (\r\n    <button onClick={handleClick}>\r\n      You clicked {countRef.current} times\r\n    </button>\r\n  );\n"})}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-refs",children:"When to use refs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Accessing or manipulating DOM elements (to focus, measure size)"}),"\n",(0,t.jsx)(n.li,{children:"Storing ids for interval/timeouts and clear them on unmount (e.g the stop watch)"}),"\n",(0,t.jsx)(n.li,{children:"When we need to store a value that doesn't trigger a re-render upon change (e.g if a effect has run)"}),"\n",(0,t.jsx)(n.li,{children:"To keep values across renders without causing re-renders."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Refs are useful with external library/ browser API however our app flows shouldn't rely on it too much"}),"\n",(0,t.jsxs)(n.li,{children:["Don't read or write ",(0,t.jsx)(n.code,{children:"ref.current"})," and use the state instead. Becuase React doesn't know when the ref.current changes"]}),"\n",(0,t.jsx)(n.li,{children:"States are like the snapshot of every render and it doesn't update synchronously"}),"\n",(0,t.jsx)(n.li,{children:"However when we update the value of ref it updates immediately."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"refs-and-the-dom",children:"Refs and the DOM"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The most common use case of useRef is to point to a DOM element"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<div ref={myRef}>"})," React puts this element as myRef.current"]}),"\n",(0,t.jsxs)(n.li,{children:["Once the element is removed from the DOM, it updates ",(0,t.jsx)(n.code,{children:"myRef.current = null"})]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"manipulating-the-dom-with-refs",children:"Manipulating the DOM with Refs"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes we need to access the DOM elements directly like to focus on an element, scroll into view, measure size etc. There's no built in way to achieve this."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"// Syntax\r\nimport { useRef } from 'react';\r\nconst myRef = useRef(null); //initialize\r\n<div ref={myRef}>\r\nmyRef.current.scrollIntoView();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"focus-on-element-using-ref",children:"Focus on element using ref"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'import { useRef } from "react";\r\n\r\nfunction MyComponent() {\r\n  const inputRef = useRef(null);\r\n\r\n  const focusInput = () => {\r\n    inputRef.current.focus(); // Access DOM element directly\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <input ref={inputRef} />\r\n      <button onClick={focusInput}>Focus Input</button>\r\n    </div>\r\n  );\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"forward-ref",children:"Forward Ref"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We can't create ref to our components directly like this ",(0,t.jsx)(n.code,{children:"<MyInput ref={inputRef} />"})]}),"\n",(0,t.jsx)(n.li,{children:"To achieve this we will have to use forward ref"}),"\n",(0,t.jsxs)(n.li,{children:["Here the actual reference is used inside ",(0,t.jsx)(n.code,{children:"MyInput"})," component"]}),"\n",(0,t.jsxs)(n.li,{children:["And we are manipulating the reference in another component that's ",(0,t.jsx)(n.code,{children:"Form"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { forwardRef, useRef } from 'react';\r\n\r\nconst MyInput = forwardRef((props, ref) => {\r\n  return <input {...props} ref={ref} />;\r\n});\r\n\r\nexport default function Form() {\r\n  const inputRef = useRef(null);\r\n\r\n  function handleClick() {\r\n    inputRef.current.focus();\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <MyInput ref={inputRef} />\r\n      <button onClick={handleClick}>\r\n        Focus the input\r\n      </button>\r\n    </>\r\n  );\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"when-react-attaches-the-refs",children:"When React attaches the refs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"React updates are basically split into two"}),"\n",(0,t.jsx)(n.li,{children:"During render phase it decides what needs to be on the screen"}),"\n",(0,t.jsx)(n.li,{children:"During commit it applies changes to the DOM"}),"\n",(0,t.jsx)(n.li,{children:"During the render, DOMs are not created yet, so ref.current will be null"}),"\n",(0,t.jsx)(n.li,{children:"React sets the ref.current during commit phase"}),"\n",(0,t.jsx)(n.li,{children:"Usually we call refs in event handlers, if there's no event then we will use effect."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"best-practices-for-dom-manipulation-with-refs",children:"Best practices for DOM manipulation with refs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use Refs to handle usecases outside of React flow like scrolling, focus etc"}),"\n",(0,t.jsx)(n.li,{children:"If we use it to modify the DOM manually it will conflict with React's updates"}),"\n",(0,t.jsx)(n.li,{children:"For example remove a button from the DOM will lead to a crash"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"<button\r\n    onClick={() => {\r\n          ref.current.remove();\r\n  }}>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"more-info",children:"More Info"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://react.dev/learn/manipulating-the-dom-with-refs#flushing-state-updates-synchronously-with-flush-sync",children:"Flushing state updates synchronously with flushSync"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>c});var t=r(6540);const s={},i=t.createContext(s);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);